这是一个基于 **Flutter + Syncfusion + Edge TTS** 的完整开发方案整理。这个方案的核心在于**“重逻辑，轻渲染”**——利用现成库的搜索功能来做高亮，利用生命周期管理来实现后台省电。

---

# Flutter PDF + Edge TTS 听书阅读器开发方案

## 1. 核心架构设计

我们将应用分为两层，严格分离关注点：

* **数据/音频层 (Service Layer)**：
* **职责**：PDF 解析、文本清洗、TTS 请求、音频播放、后台保活。
* **运行状态**：始终运行（即使 App 在后台）。


* **UI 渲染层 (Presentation Layer)**：
* **职责**：显示 PDF、响应用户手势、**执行高亮命令**。
* **运行状态**：仅在前台运行（App 切后台即停止渲染逻辑）。



---

## 2. 技术选型 (Tech Stack)

| 模块 | 库/方案 | 说明 |
| --- | --- | --- |
| **PDF UI** | `syncfusion_flutter_pdfviewer` | 业界最强 Flutter PDF 控件，自带“搜索并跳转高亮”功能。 |
| **PDF 解析** | `syncfusion_flutter_pdf` | 用于在后台提取纯文本，自动忽略图片，只提取文字对象。 |
| **音频播放** | `just_audio` | 支持流式播放，配合 `just_audio_background` 实现后台控制。 |
| **TTS 服务** | Edge TTS (WebSocket/API) | 微软的高质量语音，免费且自然。 |
| **状态管理** | GetX / Provider | 用于在 Service 和 UI 之间同步“当前读到第几句”。 |

---

## 3. 核心工作流程 (Workflow)

### 步骤一：预处理 (打开文件时)

1. 用户打开 PDF。
2. 调用 `PdfTextExtractor` 提取全书文本（此时图片已被自动过滤）。
3. **关键步骤：清洗与分句**。
* PDF 提取的文本通常包含大量不必要的换行符（硬回车）。
* 需要算法将其还原为自然段落，然后按标点符号切割成 `List<String> sentences`。



### 步骤二：播放循环 (Play Loop)

1. 读取 `currentIndex` 指向的句子。
2. 请求 Edge TTS 获取音频（MP3）。
3. 播放音频。
4. 监听播放结束事件 -> `currentIndex++` -> 递归播放下一句。

### 步骤三：高亮同步 (UI Sync)

1. **App 在前台**：
* 监听 `currentIndex` 的变化。
* 当变为 N 时，调用 `pdfViewerController.searchText(sentences[N])`。
* 界面自动跳转并高亮该句。


2. **App 在后台**：
* 停止监听 `currentIndex` 的变化。
* 音频继续播放，索引继续增加，但不触发任何 UI 操作。


3. **App 回到前台**：
* 立即读取最新的 `currentIndex`。
* 触发一次 `searchText`，将界面拉回到当前阅读位置。



---

## 4. 关键代码模块

### A. 文本清洗工具 (Text Cleaner)

PDF 的文本提取出来往往是碎的，这是保证 TTS 连贯朗读的关键。

```dart
class TextProcessUtil {
  /// 将 PDF 提取的原始文本转换为适合朗读的句子列表
  static List<String> cleanAndSplit(String rawText) {
    // 1. 去除多余的换行符，把断行的句子连起来
    // 比如： "Hello wor\nld" -> "Hello world"
    // 中文和英文处理方式略有不同，这里是通用简化版
    String cleanText = rawText.replaceAll('\r\n', ' ').replaceAll('\n', ' ');
    
    // 2. 压缩多个空格为一个
    cleanText = cleanText.replaceAll(RegExp(r'\s+'), ' ');

    // 3. 按标点符号分句 (支持中英文)
    // 正则逻辑：查找 . ? ! 。 ？ ！ 后面紧跟空白的地方进行切割
    RegExp splitPattern = RegExp(r'(?<=[.!?;。！？；])\s+');
    
    List<String> sentences = cleanText.split(splitPattern);
    
    // 4. 过滤无效短句
    return sentences.where((s) => s.trim().length > 1).toList();
  }
}

```

### B. 播放与生命周期控制器 (Controller)

```dart
class ReadingController extends State<PdfPage> with WidgetsBindingObserver {
  // ... 变量定义 ...
  
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      // 🟢 回到前台：立即同步一次视觉位置
      _highlightCurrentSentence();
    }
    // 🔴 切到后台：什么都不用做，UI 线程暂停，Timer/StreamSubscription 建议暂停 UI 更新监听
  }

  void _playNext() async {
    // 1. 播放逻辑 (始终执行)
    String text = sentences[currentIndex];
    await audioService.play(text); 
    
    // 2. UI 高亮逻辑 (仅在前台执行)
    if (AppLifecycleState.resumed == WidgetsBinding.instance.lifecycleState) {
      _highlightCurrentSentence();
    }
    
    currentIndex++;
  }

  void _highlightCurrentSentence() {
    // Syncfusion 的核心魔法：搜索即高亮
    // 注意：如果有重复句子，可能需要 searchOptions 的 nextInstance 配合
    pdfViewerController.searchText(sentences[currentIndex]);
  }
}

```

---

## 5. 潜在问题与解决方案

| 问题 | 现象 | 解决方案 |
| --- | --- | --- |
| **重复文本** | 页面上有两个“你好”，搜索定位到了第一个，但实际读的是第二个。 | 维护一个 `Map<String, int> occurrenceMap`，记录该句子在当前页是第几次出现，结合 `searchText(text, searchOption)` 的 `nextInstance` 使用。 |
| **跨页断句** | 一句话跨了两页，PDF 提取时可能被截断。 | 尽量按“自然段”提取，或者在提取文本后进行跨页合并处理（难度较大，MVP 阶段建议忽略）。 |
| **TTS 延迟** | 每句话之间请求网络，有 1-2 秒空白。 | **预加载策略**：正在读第 N 句时，后台静默请求第 N+1 句的音频并缓存。 |

## 6. 下一步行动建议

1. **先跑通 MVP**：不要做复杂的文本清洗，先试着把 PDF 文本提取出来，分割成数组，点击按钮能让 PDF Viewer 高亮数组里的某一句话。
2. **合并**：把声音播放结束的回调，绑定到“下一句 + 高亮”的逻辑上。

这个方案结构清晰，利用了成熟的库避开了底层开发的深坑，是性价比最高的实现路径。


# 包名
android.com.hnwd.pdf_reader 

