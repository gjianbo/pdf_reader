# 项目开发规则

## 一、代码注释规范

### 1.1 文件头注释
每个源文件必须包含文件头注释，说明文件用途、作者、创建日期等信息。

```dart
/// 文件名称：anti_addiction_system.dart
/// 功能描述：防沉迷系统核心实现，包括时间管理、护眼提醒、家长控制等功能
/// 作者：开发团队
/// 创建日期：2025-12-30
/// 修改记录：
///   - 2025-12-30: 初始版本创建
library;
```

### 1.2 类注释
每个类必须有注释，说明类的功能、职责和使用场景。

```dart
/// 防沉迷系统核心类
/// 
/// 负责管理用户的使用时长、护眼提醒、家长控制等功能
/// 
/// 使用示例：
/// ```dart
/// final antiAddiction = AntiAddictionSystem();
/// await antiAddiction.initialize();
/// antiAddiction.startSession();
/// ```
class AntiAddictionSystem {
  // 类实现
}
```

### 1.3 函数注释
每个公开函数必须有注释，说明函数的功能、参数、返回值和异常情况。

```dart
/// 开始会话计时
/// 
/// 启动会话计时器，开始记录用户使用时长
/// 
/// 参数：
/// - [userId] 用户ID
/// 
/// 返回值：
/// - Future<void> 异步操作完成
/// 
/// 异常：
/// - [SessionAlreadyStartedException] 当会话已经启动时抛出
/// 
/// 示例：
/// ```dart
/// try {
///   await startSession('user123');
/// } on SessionAlreadyStartedException {
///   print('会话已经启动');
/// }
/// ```
Future<void> startSession(String userId) async {
  // 函数实现
}
```

### 1.4 变量注释
重要的成员变量必须有注释，说明变量的用途和含义。

```dart
/// 会话计时器，用于记录单次使用时长
Timer? _sessionTimer;

/// 每日使用时长限制（单位：分钟）
/// 默认值为60分钟，可通过家长控制修改
int _dailyLimit = 60;

/// 护眼提醒间隔（单位：分钟）
/// 默认值为10分钟
int _eyeCareInterval = 10;
```

### 1.5 代码块注释
复杂的代码块必须有注释，说明代码的逻辑和实现思路。

```dart
/// 计算用户剩余使用时长
/// 
/// 逻辑说明：
/// 1. 获取今日已使用时长
/// 2. 减去每日限制时长
/// 3. 如果结果为负，返回0
/// 4. 否则返回剩余时长
int getRemainingTime() {
  final usedTime = _getDailyUsedTime();
  final remaining = _dailyLimit - usedTime;
  return remaining > 0 ? remaining : 0;
}
```

### 1.6 TODO注释
使用TODO注释标记待完成的功能或需要改进的地方。

```dart
// TODO: 添加周末/工作日不同的时长限制
// TODO: 优化护眼提醒动画效果
// TODO: 支持多设备同步使用时长
```

### 1.7 注释语言
- 注释使用中文编写，便于团队理解
- 技术术语使用英文，如"Timer"、"Future"等
- 示例代码中的变量名和函数名使用英文

## 二、Todo管理规范

### 2.1 Todo创建时机
在开始实现任何功能之前，必须先创建Todo任务。

**必须创建Todo的情况：**
- 开始实现新的功能模块
- 修复已知的Bug
- 进行代码重构
- 添加新的测试用例
- 优化性能或用户体验

### 2.2 Todo任务格式
Todo任务必须包含以下信息：
- **id**: 唯一标识符（数字）
- **content**: 任务描述（清晰、具体、可衡量）
- **status**: 任务状态（pending/in_progress/completed）
- **priority**: 任务优先级（high/medium/low）

**示例：**
```json
{
  "id": "1",
  "content": "实现防沉迷系统的会话计时功能",
  "status": "pending",
  "priority": "high"
}
```

### 2.3 Todo状态管理

#### 2.3.1 状态定义
- **pending**: 待开始，任务已创建但未开始实施
- **in_progress**: 进行中，任务正在实施
- **completed**: 已完成，任务已完成并通过验证

#### 2.3.2 状态转换规则
1. **pending → in_progress**: 开始实施任务时
2. **in_progress → completed**: 任务完成并通过验证时
3. **in_progress → pending**: 任务暂停或需要重新规划时

#### 2.3.3 状态更新时机
- **开始任务时**: 将状态从pending改为in_progress
- **完成任务时**: 将状态从in_progress改为completed
- **任务暂停时**: 将状态从in_progress改为pending，并在content中说明原因

### 2.4 Todo优先级定义

#### 2.4.1 优先级级别
- **high**: 高优先级，必须立即处理
  - 核心功能实现
  - 严重Bug修复
  - 阻塞性问题解决
  - 用户关键需求

- **medium**: 中优先级，按计划处理
  - 功能增强
  - 性能优化
  - 代码重构
  - 一般Bug修复

- **low**: 低优先级，有时间时处理
  - UI美化
  - 文档完善
  - 非关键功能
  - 代码优化

#### 2.4.2 优先级分配原则
1. 根据任务对项目目标的影响程度分配优先级
2. 高优先级任务数量不宜过多（建议不超过总数的30%）
3. 优先级应根据实际情况动态调整

### 2.5 Todo任务粒度

#### 2.5.1 任务粒度原则
- 每个Todo任务应该是可独立完成的工作单元
- 任务完成时间建议在2-8小时之间
- 避免任务过大或过小

#### 2.5.2 任务拆分示例

**过大任务（需要拆分）：**
```json
{
  "id": "1",
  "content": "实现防沉迷系统",
  "status": "pending",
  "priority": "high"
}
```

**拆分后的任务：**
```json
{
  "id": "1",
  "content": "设计防沉迷系统架构",
  "status": "pending",
  "priority": "high"
},
{
  "id": "2",
  "content": "实现会话计时功能",
  "status": "pending",
  "priority": "high"
},
{
  "id": "3",
  "content": "实现护眼提醒功能",
  "status": "pending",
  "priority": "high"
},
{
  "id": "4",
  "content": "实现家长控制功能",
  "status": "pending",
  "priority": "high"
},
{
  "id": "5",
  "content": "编写防沉迷系统单元测试",
  "status": "pending",
  "priority": "medium"
}
```

### 2.6 Todo使用流程

#### 2.6.1 开始新功能开发
1. 分析需求，明确功能目标
2. 将功能拆分为多个Todo任务
3. 使用TodoWrite工具创建所有Todo任务
4. 将第一个任务状态设置为in_progress
5. 开始实施任务

#### 2.6.2 任务实施过程
1. 按照Todo任务列表逐个实施
2. 完成一个任务后，立即更新状态为completed
3. 开始下一个任务前，将状态设置为in_progress
4. 遇到问题时，及时更新Todo内容或优先级

#### 2.6.3 任务完成验证
1. 功能实现完成后，进行自测
2. 确认功能符合需求
3. 运行测试用例，确保无回归
4. 更新Todo状态为completed

### 2.7 Todo示例

#### 2.7.1 阶段一：基础框架搭建
```json
[
  {
    "id": "1",
    "content": "初始化Flutter项目结构",
    "status": "pending",
    "priority": "high"
  },
  {
    "id": "2",
    "content": "实现应用启动流程和首次引导",
    "status": "pending",
    "priority": "high"
  },
  {
    "id": "3",
    "content": "实现身份选择界面（家长/儿童）",
    "status": "pending",
    "priority": "high"
  },
  {
    "id": "4",
    "content": "实现防沉迷系统核心功能",
    "status": "pending",
    "priority": "high"
  },
  {
    "id": "5",
    "content": "实现底部导航框架",
    "status": "pending",
    "priority": "high"
  }
]
```

#### 2.7.2 阶段二：单机益智乐园
```json
[
  {
    "id": "6",
    "content": "实现数字华容道游戏逻辑",
    "status": "pending",
    "priority": "high"
  },
  {
    "id": "7",
    "content": "实现数字华容道UI界面",
    "status": "pending",
    "priority": "high"
  },
  {
    "id": "8",
    "content": "实现汉字拼图游戏逻辑",
    "status": "pending",
    "priority": "high"
  },
  {
    "id": "9",
    "content": "实现汉字拼图UI界面",
    "status": "pending",
    "priority": "high"
  },
  {
    "id": "10",
    "content": "实现难度分级系统",
    "status": "pending",
    "priority": "medium"
  },
  {
    "id": "11",
    "content": "实现成就系统",
    "status": "pending",
    "priority": "medium"
  },
  {
    "id": "12",
    "content": "实现本地进度保存功能",
    "status": "pending",
    "priority": "high"
  }
]
```

## 三、代码规范

### 3.1 命名规范

#### 3.1.1 文件命名
- 使用小写字母和下划线
- 文件名应清晰描述文件内容
- 示例：`anti_addiction_system.dart`、`digital_puzzle.dart`

#### 3.1.2 类命名
- 使用大驼峰命名法（PascalCase）
- 类名应为名词
- 示例：`AntiAddictionSystem`、`DigitalPuzzleGame`

#### 3.1.3 函数命名
- 使用小驼峰命名法（camelCase）
- 函数名应为动词或动词短语
- 示例：`startSession()`、`getRemainingTime()`、`calculateScore()`

#### 3.1.4 变量命名
- 使用小驼峰命名法（camelCase）
- 变量名应为名词
- 私有变量使用下划线前缀
- 示例：`sessionTimer`、`dailyLimit`、`_sessionTimer`

#### 3.1.5 常量命名
- 使用小写字母和下划线
- 全大写也可以，但建议使用小写
- 示例：`daily_limit`、`eye_care_interval`、`MAX_SESSION_TIME`

### 3.2 代码组织

#### 3.2.1 文件组织
```
lib/
├── main.dart                      # 应用入口
├── config/                        # 配置文件
│   ├── app_config.dart
│   └── constants.dart
├── core/                          # 核心功能
│   ├── anti_addiction/
│   │   ├── anti_addiction_system.dart
│   │   └── models/
│   ├── storage/
│   │   ├── hive_storage.dart
│   │   └── shared_preferences_storage.dart
│   └── network/
│       ├── udp_discovery.dart
│       └── tcp_connection.dart
├── features/                      # 功能模块
│   ├── puzzle_games/
│   │   ├── digital_puzzle/
│   │   └── character_puzzle/
│   ├── lan_battle/
│   │   ├── gomoku/
│   │   └── room_discovery/
│   ├── learning_house/
│   │   ├── dictation/
│   │   ├── handwriting/
│   │   └── mistake_book/
│   └── ai_tutor/
│       ├── gomoku_ai/
│       └── math_practice/
├── ui/                            # UI组件
│   ├── widgets/
│   ├── screens/
│   └── themes/
└── utils/                         # 工具类
    ├── logger.dart
    ├── validators.dart
    └── helpers.dart
```

#### 3.2.2 导入顺序
```dart
// 1. Dart核心库
import 'dart:async';
import 'dart:convert';

// 2. Flutter框架
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

// 3. 第三方包
import 'package:hive/hive.dart';
import 'package:shared_preferences/shared_preferences.dart';

// 4. 项目内部导入
import '../config/app_config.dart';
import '../core/anti_addiction/anti_addiction_system.dart';
```

### 3.3 错误处理

#### 3.3.1 异常定义
```dart
/// 会话已启动异常
class SessionAlreadyStartedException implements Exception {
  final String message;
  
  SessionAlreadyStartedException(this.message);
  
  @override
  String toString() => 'SessionAlreadyStartedException: $message';
}
```

#### 3.3.2 异常处理
```dart
try {
  await startSession(userId);
} on SessionAlreadyStartedException catch (e) {
  logger.error('会话启动失败: $e');
  showErrorDialog('会话已经启动，请勿重复操作');
} catch (e) {
  logger.error('未知错误: $e');
  showErrorDialog('操作失败，请稍后重试');
}
```

### 3.4 日志规范

#### 3.4.1 日志级别
- **debug**: 调试信息，仅在开发环境使用
- **info**: 一般信息，记录重要操作
- **warning**: 警告信息，记录潜在问题
- **error**: 错误信息，记录错误和异常

#### 3.4.2 日志使用
```dart
// 调试信息
logger.debug('开始会话计时: userId=$userId');

// 一般信息
logger.info('用户登录成功: userId=$userId');

// 警告信息
logger.warning('会话时长即将达到限制: remainingTime=$remainingTime');

// 错误信息
logger.error('会话启动失败', error: e, stackTrace: stackTrace);
```

## 四、测试规范

### 4.1 单元测试
- 每个核心类必须有对应的单元测试
- 测试覆盖率应达到80%以上
- 测试文件命名：`*_test.dart`

```dart
void main() {
  group('AntiAddictionSystem', () {
    test('应该正确计算剩余时长', () {
      final system = AntiAddictionSystem();
      expect(system.getRemainingTime(), greaterThan(0));
    });
  });
}
```

### 4.2 集成测试
- 重要功能模块必须有集成测试
- 测试文件命名：`*_integration_test.dart`

### 4.3 Widget测试
- 重要UI组件必须有Widget测试
- 测试文件命名：`*_widget_test.dart`

## 五、Git提交规范

### 5.1 提交信息格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

### 5.2 Type类型
- **feat**: 新功能
- **fix**: Bug修复
- **docs**: 文档更新
- **style**: 代码格式调整
- **refactor**: 代码重构
- **test**: 测试相关
- **chore**: 构建/工具相关

### 5.3 提交示例
```
feat(anti-addiction): 实现会话计时功能

- 添加会话计时器
- 实现时长计算逻辑
- 添加超时提醒

Closes #123
```

## 六、文档规范

### 6.1 README
- 项目根目录必须有README.md
- 包含项目介绍、安装说明、使用指南

### 6.2 API文档
- 公开API必须有文档注释
- 使用dartdoc生成API文档

### 6.3 设计文档
- 重要功能模块必须有设计文档
- 存放在doc目录下

## 七、代码审查规范

### 7.1 审查要点
- 代码是否符合规范
- 注释是否完整
- 是否有明显的Bug
- 性能是否合理
- 安全性是否考虑

### 7.2 审查流程
1. 提交Pull Request
2. 至少一人审查通过
3. 修改审查意见
4. 合并到主分支

### 7.3 代码质量验证
- 修改完成后，必须使用 `flutter analyze` 检查代码，并修复所有出现的错误
- 禁止将存在 `flutter analyze` 错误的代码提交到代码仓库
- 代码审查前必须确保 `flutter analyze` 检查无错误

## 八、Flutter/移动端特有规范

### 8.1 Widget拆分规范

#### 8.1.1 文件行数限制
- 单个Widget文件行数不超过200行
- 超过限制必须拆分为多个Widget文件
- 便于代码维护和热重载优化

#### 8.1.2 Widget拆分原则
- 复杂的build方法必须拆分为小型、无状态的Private Widget
- 禁止在类中定义大量的`_buildXXX()`返回Widget的函数
- 每个Widget职责单一，可复用性强

**错误示例：**
```dart
class DigitalPuzzleScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          _buildHeader(),
          _buildGameBoard(),
          _buildControls(),
          _buildFooter(),
        ],
      ),
    );
  }

  Widget _buildHeader() { /* ... */ }
  Widget _buildGameBoard() { /* ... */ }
  Widget _buildControls() { /* ... */ }
  Widget _buildFooter() { /* ... */ }
}
```

**正确示例：**
```dart
class DigitalPuzzleScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: const [
          PuzzleHeader(),
          PuzzleGameBoard(),
          PuzzleControls(),
          PuzzleFooter(),
        ],
      ),
    );
  }
}

class PuzzleHeader extends StatelessWidget {
  const PuzzleHeader({super.key});

  @override
  Widget build(BuildContext context) {
    // 头部实现
  }
}

class PuzzleGameBoard extends StatelessWidget {
  const PuzzleGameBoard({super.key});

  @override
  Widget build(BuildContext context) {
    // 游戏棋盘实现
  }
}
```

### 8.2 状态管理规范

#### 8.2.1 统一状态管理框架
- 项目统一使用Provider作为状态管理框架
- 禁止混用多种状态管理方案（如Riverpod、Bloc等）
- 所有状态变更必须通过Provider进行

#### 8.2.2 Provider使用规范
- 使用`ChangeNotifier`或`StateNotifier`管理状态
- 使用`Consumer`或`Selector`监听状态变化
- 避免在build方法中创建Provider

**示例：**
```dart
/// 游戏状态管理类
class GameProvider extends ChangeNotifier {
  int _score = 0;
  bool _isGameOver = false;

  int get score => _score;
  bool get isGameOver => _isGameOver;

  /// 更新分数
  void updateScore(int points) {
    _score += points;
    notifyListeners();
  }

  /// 结束游戏
  void endGame() {
    _isGameOver = true;
    notifyListeners();
  }
}
```

### 8.3 资源管理规范

#### 8.3.1 资源路径常量化
- 图片、音效等资源必须在`assets.dart`中定义常量路径
- 严禁在UI代码中硬编码字符串路径
- 统一管理，便于维护和替换

**assets.dart示例：**
```dart
/// 资源路径常量类
class AppAssets {
  AppAssets._();

  // 图片资源
  static const String iconHome = 'assets/icons/home.png';
  static const String iconGame = 'assets/icons/game.png';
  static const String iconLearning = 'assets/icons/learning.png';
  static const String iconAi = 'assets/icons/ai.png';

  // 背景图片
  static const String bgHome = 'assets/backgrounds/home.png';
  static const String bgGame = 'assets/backgrounds/game.png';

  // 音效资源
  static const String sfxClick = 'assets/sounds/click.mp3';
  static const String sfxSuccess = 'assets/sounds/success.mp3';
  static const String sfxError = 'assets/sounds/error.mp3';

  // 背景音乐
  static const String bgmMain = 'assets/music/main.mp3';
  static const String bgmGame = 'assets/music/game.mp3';
}
```

**使用示例：**
```dart
Image.asset(AppAssets.iconHome)
AudioPlayer.play(AppAssets.sfxClick)
```

#### 8.3.2 资源文件组织
```
assets/
├── icons/          # 图标资源
│   ├── home.png
│   ├── game.png
│   └── learning.png
├── backgrounds/    # 背景图片
│   ├── home.png
│   └── game.png
├── sounds/         # 音效资源
│   ├── click.mp3
│   ├── success.mp3
│   └── error.mp3
└── music/          # 背景音乐
    ├── main.mp3
    └── game.mp3
```

### 8.4 国际化规范

#### 8.4.1 多语言支持
- 所有UI文本必须通过`l10n`引用
- 支持中文、英文两种语言
- 考虑未来出海需求，预留多语言扩展

#### 8.4.2 国际化配置
- 使用`flutter_localizations`和`intl`包
- 在`lib/l10n`目录下管理多语言文件
- 文本键名使用小写字母和下划线

**l10n目录结构：**
```
lib/l10n/
├── app_en.arb       # 英文翻译
├── app_zh.arb       # 中文翻译
└── app_localizations.dart  # 自动生成的本地化类
```

**app_zh.arb示例：**
```json
{
  "appTitle": "亲子益智乐园",
  "home": "首页",
  "game": "游戏",
  "learning": "学习",
  "ai_tutor": "AI导师",
  "start_game": "开始游戏",
  "pause": "暂停",
  "resume": "继续",
  "exit": "退出"
}
```

**使用示例：**
```dart
Text(AppLocalizations.of(context)!.appTitle)
```

## 九、性能与体验规范

### 9.1 音效与震动规范

#### 9.1.1 音效管理
- 使用全局音效管理类统一管理音效
- 支持一键静音功能
- 区分背景音乐（BGM）和交互音效（SFX）

**音效管理类示例：**
```dart
/// 音效管理类
class AudioManager {
  static final AudioManager _instance = AudioManager._internal();
  factory AudioManager() => _instance;
  AudioManager._internal();

  AudioPlayer? _bgmPlayer;
  AudioPlayer? _sfxPlayer;

  bool _isMuted = false;
  double _bgmVolume = 0.5;
  double _sfxVolume = 0.8;

  /// 播放背景音乐
  Future<void> playBGM(String assetPath) async {
    if (_isMuted) return;
    _bgmPlayer ??= AudioPlayer();
    await _bgmPlayer!.setAsset(assetPath);
    await _bgmPlayer!.setVolume(_bgmVolume);
    await _bgmPlayer!.setLoopMode(LoopMode.one);
    await _bgmPlayer!.play();
  }

  /// 播放音效
  Future<void> playSFX(String assetPath) async {
    if (_isMuted) return;
    _sfxPlayer ??= AudioPlayer();
    await _sfxPlayer!.setAsset(assetPath);
    await _sfxPlayer!.setVolume(_sfxVolume);
    await _sfxPlayer!.play();
  }

  /// 静音切换
  void toggleMute() {
    _isMuted = !_isMuted;
    if (_isMuted) {
      _bgmPlayer?.pause();
    } else {
      _bgmPlayer?.resume();
    }
  }

  /// 停止所有音效
  void stopAll() {
    _bgmPlayer?.stop();
    _sfxPlayer?.stop();
  }
}
```

#### 9.1.2 震动反馈
- 使用`vibration`包提供震动反馈
- 区分不同强度的震动反馈
- 支持关闭震动功能

**震动反馈示例：**
```dart
/// 播放震动反馈
Future<void> vibrate(VibrationType type) async {
  if (!Vibration.hasVibrator()) return;

  switch (type) {
    case VibrationType.light:
      Vibration.vibrate(duration: 50);
      break;
    case VibrationType.medium:
      Vibration.vibrate(duration: 100);
      break;
    case VibrationType.heavy:
      Vibration.vibrate(duration: 200);
      break;
    case VibrationType.success:
      Vibration.vibrate(pattern: [0, 50, 50, 50]);
      break;
    case VibrationType.error:
      Vibration.vibrate(pattern: [0, 100, 50, 100]);
      break;
  }
}
```

### 9.2 离线优先规范

#### 9.2.1 本地数据持久化
- 核心数据必须通过Hive数据库持久化
- 配置数据使用SharedPreferences存储
- 明确哪些数据必须离线可用

**必须离线可用的数据：**
- 用户身份信息（家长/儿童）
- 防沉迷设置（时长限制、护眼提醒）
- 游戏进度和成绩
- 错题本数据
- 成就和徽章

#### 9.2.2 同步策略
- 网络可用时自动同步到云端
- 网络断开时使用本地数据
- 冲突解决策略：本地优先，云端覆盖

**同步策略示例：**
```dart
/// 数据同步管理类
class SyncManager {
  /// 同步用户数据
  Future<void> syncUserData() async {
    if (!await NetworkManager.isConnected()) {
      logger.info('网络不可用，使用本地数据');
      return;
    }

    try {
      final localData = await HiveStorage.getUserData();
      await CloudApi.syncUserData(localData);
      logger.info('用户数据同步成功');
    } catch (e) {
      logger.error('用户数据同步失败: $e');
    }
  }
}
```

### 9.3 防误触规范

#### 9.3.1 按钮热区规范
- 所有可点击元素的最小热区为44x44dp
- 重要按钮热区建议为48x48dp或更大
- 确保儿童能够准确点击

**按钮热区示例：**
```dart
/// 游戏按钮组件
class GameButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;

  const GameButton({
    super.key,
    required this.text,
    this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 120,
      height: 48,
      child: ElevatedButton(
        onPressed: onPressed,
        style: ElevatedButton.styleFrom(
          minimumSize: const Size(120, 48),
        ),
        child: Text(text),
      ),
    );
  }
}
```

#### 9.3.2 连续点击防抖
- 重要操作需要防抖处理
- 防抖时间建议为500ms-1000ms
- 防止儿童快速重复点击

**防抖处理示例：**
```dart
/// 防抖按钮组件
class DebouncedButton extends StatefulWidget {
  final Widget child;
  final VoidCallback? onPressed;
  final Duration debounceTime;

  const DebouncedButton({
    super.key,
    required this.child,
    this.onPressed,
    this.debounceTime = const Duration(milliseconds: 500),
  });

  @override
  State<DebouncedButton> createState() => _DebouncedButtonState();
}

class _DebouncedButtonState extends State<DebouncedButton> {
  DateTime? _lastPressedTime;

  void _handlePress() {
    final now = DateTime.now();
    if (_lastPressedTime == null ||
        now.difference(_lastPressedTime!) >= widget.debounceTime) {
      _lastPressedTime = now;
      widget.onPressed?.call();
    }
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: _handlePress,
      child: widget.child,
    );
  }
}
```

## 十、安全与隐私规范

### 10.1 隐私保护规范

#### 10.1.1 日志脱敏处理
- 严禁在日志中打印用户的真实姓名
- 严禁在日志中打印家长手机号
- 严禁在日志中打印定位信息
- 严禁在日志中打印身份证号等敏感信息

**日志脱敏示例：**
```dart
/// 日志脱敏工具类
class LogMasker {
  /// 脱敏手机号
  static String maskPhone(String phone) {
    if (phone.length != 11) return phone;
    return '${phone.substring(0, 3)}****${phone.substring(7)}';
  }

  /// 脱敏姓名
  static String maskName(String name) {
    if (name.isEmpty) return name;
    if (name.length == 1) return '*';
    return '${name[0]}${'*' * (name.length - 1)}';
  }

  /// 脱敏身份证号
  static String maskIdCard(String idCard) {
    if (idCard.length < 8) return idCard;
    return '${idCard.substring(0, 4)}********${idCard.substring(idCard.length - 4)}';
  }
}

// 使用示例
logger.info('用户登录: phone=${LogMasker.maskPhone(phone)}');
```

#### 10.1.2 本地存储加密
- 家长密码必须加密存储
- 敏感配置信息建议加密
- 使用Flutter的`flutter_secure_storage`包

**加密存储示例：**
```dart
/// 安全存储管理类
class SecureStorageManager {
  static const _storage = FlutterSecureStorage();

  /// 保存家长密码
  static Future<void> saveParentPassword(String password) async {
    final encrypted = _encryptPassword(password);
    await _storage.write(key: 'parent_password', value: encrypted);
  }

  /// 获取家长密码
  static Future<String?> getParentPassword() async {
    final encrypted = await _storage.read(key: 'parent_password');
    if (encrypted == null) return null;
    return _decryptPassword(encrypted);
  }

  /// 加密密码
  static String _encryptPassword(String password) {
    // 使用加密算法加密密码
    return base64Encode(utf8.encode(password));
  }

  /// 解密密码
  static String _decryptPassword(String encrypted) {
    return utf8.decode(base64Decode(encrypted));
  }
}
```

### 10.2 家长鉴权规范

#### 10.2.1 家长中心进入验证
- 进入家长中心必须通过验证
- 验证方式：算术题、长按3秒、密码输入
- 防止儿童误操作进入

**家长验证示例：**
```dart
/// 家长验证对话框
class ParentVerificationDialog extends StatefulWidget {
  final VoidCallback onVerified;

  const ParentVerificationDialog({
    super.key,
    required this.onVerified,
  });

  @override
  State<ParentVerificationDialog> createState() => _ParentVerificationDialogState();
}

class _ParentVerificationDialogState extends State<ParentVerificationDialog> {
  int _num1 = 0;
  int _num2 = 0;
  int _answer = 0;
  String _inputAnswer = '';

  @override
  void initState() {
    super.initState();
    _generateQuestion();
  }

  /// 生成算术题
  void _generateQuestion() {
    final random = Random();
    _num1 = random.nextInt(10) + 1;
    _num2 = random.nextInt(10) + 1;
    _answer = _num1 + _num2;
  }

  /// 验证答案
  void _verifyAnswer() {
    final input = int.tryParse(_inputAnswer);
    if (input == _answer) {
      Navigator.of(context).pop();
      widget.onVerified();
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('答案错误，请重试')),
      );
      _generateQuestion();
      setState(() {
        _inputAnswer = '';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('家长验证'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text('请计算：$_num1 + $_num2 = ?'),
          const SizedBox(height: 16),
          TextField(
            keyboardType: TextInputType.number,
            onChanged: (value) {
              _inputAnswer = value;
            },
            decoration: const InputDecoration(
              border: OutlineInputBorder(),
              labelText: '输入答案',
            ),
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('取消'),
        ),
        ElevatedButton(
          onPressed: _verifyAnswer,
          child: const Text('确认'),
        ),
      ],
    );
  }
}
```

#### 10.2.2 关键设置修改验证
- 修改防沉迷设置需要家长验证
- 修改家长密码需要旧密码验证
- 删除数据需要二次确认

## 十一、UI适配与视觉规范

### 11.1 屏幕适配方案

#### 11.1.1 适配库选择
- 使用`flutter_screenutil`进行屏幕适配
- 基准设计稿尺寸：375x667（iPhone SE）
- 必须适配手机和平板两种比例

**适配配置示例：**
```dart
void main() async {
  await ScreenUtil.ensureScreenSize();
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return ScreenUtilInit(
      designSize: const Size(375, 667),
      minTextAdapt: true,
      splitScreenMode: true,
      builder: (context, child) {
        return MaterialApp(
          home: child,
        );
      },
      child: const HomePage(),
    );
  }
}
```

#### 11.1.2 尺寸使用规范
- 使用`.w`、`.h`、`.sp`进行尺寸适配
- 禁止使用硬编码的像素值
- 文字大小使用`.sp`，其他尺寸使用`.w`和`.h`

**适配使用示例：**
```dart
Container(
  width: 200.w,
  height: 100.h,
  padding: EdgeInsets.all(16.w),
  child: Text(
    'Hello',
    style: TextStyle(fontSize: 16.sp),
  ),
)
```

### 11.2 主题色彩规范

#### 11.2.1 主题色彩定义
- 必须使用`Theme.of(context).colorScheme`获取颜色
- 严禁在代码中直接写`Colors.blue`或`0xFF...`
- 支持护眼模式和深色模式切换

**主题配置示例：**
```dart
/// 应用主题配置
class AppTheme {
  /// 浅色主题
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF667EEA),
        brightness: Brightness.light,
      ),
    );
  }

  /// 深色主题
  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF667EEA),
        brightness: Brightness.dark,
      ),
    );
  }

  /// 护眼模式主题
  static ThemeData get eyeCareTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF8BC34A),
        brightness: Brightness.light,
      ),
    );
  }
}
```

#### 11.2.2 颜色使用规范
- 使用`Theme.of(context).colorScheme.primary`获取主色
- 使用`Theme.of(context).colorScheme.secondary`获取辅色
- 使用`Theme.of(context).colorScheme.error`获取错误色
- 使用`Theme.of(context).colorScheme.surface`获取背景色

**颜色使用示例：**
```dart
Container(
  color: Theme.of(context).colorScheme.primary,
  child: Text(
    'Hello',
    style: TextStyle(
      color: Theme.of(context).colorScheme.onPrimary,
    ),
  ),
)
```

## 十二、依赖管理规范

### 12.1 版本锁死规范

#### 12.1.1 依赖版本管理
- 核心插件建议使用固定版本号
- 非核心插件使用兼容版本号（^）
- 避免因第三方库升级导致构建失败

**pubspec.yaml示例：**
```yaml
dependencies:
  flutter:
    sdk: flutter

  # 核心插件 - 固定版本
  provider: ^6.1.1
  hive: ^2.2.3
  hive_flutter: ^1.1.0
  shared_preferences: ^2.2.2
  flutter_screenutil: ^5.9.0

  # 网络相关
  dio: ^5.4.0

  # 音效相关
  audioplayers: ^5.2.1
  vibration: ^1.8.4

  # 安全存储
  flutter_secure_storage: ^9.0.0

  # 国际化
  flutter_localizations:
    sdk: flutter
  intl: ^0.18.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.1
  build_runner: ^2.4.8
  hive_generator: ^2.0.1
```

### 12.2 插件引入审批

#### 12.2.1 插件引入原则
- 禁止随意引入功能重复的插件
- 禁止引入长期不维护的插件
- 引入新插件需经过团队评估

#### 12.2.2 插件评估标准
- 插件维护活跃度（最近更新时间）
- 插件流行度（下载量、点赞数）
- 插件兼容性（Flutter版本兼容）
- 插件性能（包大小、运行性能）
- 插件安全性（是否有已知漏洞）

**插件引入流程：**
1. 提交插件引入申请
2. 团队评估插件质量和必要性
3. 评估通过后引入
4. 记录插件引入原因和使用场景

## 十三、总结

本规范旨在提高代码质量、团队协作效率和项目可维护性。所有团队成员应严格遵守本规范，并在实践中不断完善和优化。

**核心原则：**
1. 注释先行，代码清晰
2. Todo管理，任务明确
3. 规范统一，风格一致
4. 测试覆盖，质量保证
5. 文档完善，易于维护
6. 性能优先，体验至上
7. 安全合规，隐私保护
8. 适配全面，视觉统一